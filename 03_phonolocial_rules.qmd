# Введение в `twol`: (мор)фонология

## Фонологическое введение

Преобладающая фонологическая теория в XX веке --- генеративная фонология [@chomsky1968]. Согласно этой теории существует два представления: глубинное (underlying/phonological representation) и поверхностное (surface form, phonetic representation). Фонология в этой теории сводится к набору линейено упорядоченных правил, которые применяются циклически, преобразуя результат работы синтаксической деревации в фонетические цепочки.

(@) глубинное представление > фонологическое правило 1 > фонологическое правило 2 > ... > поверхностное представление.

Из-за того, что правила в этой теории строго упорядочены возникают случаи, когда правила взаимодействуют друг с другом. Классификация таких случаев приводится в работе [@kiparsky1982]:

- питающий порядок (feeding). Так называют порядок, при котором применение одного правила увеличивает количество контекстов применение другого правила, так что другое правило срабатывает. [^feeding]
- блокирующий порядок (bleeding). Так называют порядок, при котором применение одного правила уменьшает количество контекстов применения другого правила, так что другое правило не срабатывает. [^bleedong]
- противопитающий порядок (counterfeeding). Так называют порядок, при котором применение одного правила увеличивает
количество контекстов применение другого правила, однако другое правило не срабатывает.
- противоблокирующий порядок (counterbleeding). Так называют порядок, при котором применение одного правила уменьшает
количество контекстов применения другого правила, однако другое правило все равно срабатывает.

[^feeding]: Вот пример питающего порядка из бразильского португальского (индоевропейские).

    | правило       | форма      | транскрипция      | глосса       |
    |---------------|------------|-------------------|--------------|
    | палатализация | bato       | [bá**t**u]        | бить-1sg     |
    | палатализация | bate       | [bá**tʃ**i]       | бить-3sg     |
    | палатализация | ardo       | [áɾ**d**u]        | жечь-1sg     |
    | палатализация | arde       | [áɾ**dʒ**i]       | жечь-3sg     |
    | эпентеза i    | pacto      | [pák**i**tu]      | соглашение   |
    | эпентеза i    | captar     | [kap**i**táɾ]     | взять в плен |
    | эпентеза i    | psicologia | [p**i**sikoloʒíɐ] | психология   |
    
    А вот взаимодействие правил:
    
    |               | /kaptáɾ/ <br> взять в плен | /áɾdi/ <br> жечь-3sg | /advɛ́χsu/ <br> враждебный | /futbɔ́w/ <br> футбол |
    |---------------|:--------------------------:|:--------------------:|:-------------------------:|:--------------------:|
    | эпентеза I    |           kapitáɾ          |          ---         |          adivɛ́χsu         |        futibɔ́w       |
    | палатализация |             ---            |         áɾdʒi        |         adʒivɛ́χsu         |       futʃibɔ́w       |

[^bleedong]: Вот пример питающего порядка из литовского (индоевропейские).

    | правило    | транскрипция         | перевод   |
    |------------|----------------------|-----------|
    | эпентеза i | [at-koːpʲtʲi]        | прийти    |
    | эпентеза i | [atʲ**i**-tʲeisʲtʲi] | присудить |
    | эпентеза i | [ap-kalʲbʲetʲi]      | оговорить |
    | эпентеза i | [apʲ**i**-putʲi]     | подгнить  |
    | озвончение | [at-praʃʲiːtʲi]      | спросить  |
    | озвончение | [a**d**-gautʲi]      | вернуть   |
    | озвончение | [ap-ʃaukjtji]        | объявить  |
    | озвончение | [a**b**-gautji]      | обмануть  |
    
    А вот взаимодействие правил:
    
    |            | /ap-putʲi/ <br> подгнить | /at-gautʲi/ <br> вернуть | /at-duotʲi/ <br> отдать | /ap-bʲekʲtʲi/ <br> обежать |
    |------------|:------------------------:|:------------------------:|:-----------------------:|:--------------------------:|
    | эпентеза i |        apʲi-putʲi        |            ---           |       atʲi-duotʲi       |        apʲi-bʲekʲtʲi       |
    | озвончение |            ---           |         ad-gautʲi        |           ---           |             ---            |


Вот комиксы, которые по нашей задумке должны дополнительно иллюстрировать разницу между разными порядками.

```{r}
#| layout-ncol: 2

knitr::include_graphics("images/03_01_Russita-feeding.png")
knitr::include_graphics("images/03_02_Russita-bleeding.png")
knitr::include_graphics("images/03_03_Russita-counterfeeding.png")
knitr::include_graphics("images/03_04_Russita-counterbleeding.png")
```

## Двухуровневая фонология/морфология

Двухуровневая фонология/морфология (two level morphology) была разработана в диссертации [@koskenniemi1983]. Стоит отметить, что мы используем данный формализм для моделирования (мор)фонологических правил, однако данный формализм называют двухуровневой морфологией (в том числе и сам автор). Вообще, еще в 1972 вышла диссертация [@johnson1972], в которой автор указывал на некоторые недостатки последовательности фонологических правил, которые были приняты в генеративной фонологии, а также доказывал, что любую последовательность правил можно моделировать при помощи трансдьюсера, однако эта работа осталась незамеченной.

В рамках двухуровневой фонологии/морфологии:

- правила --- посимвольные ограничения на поверхностное представление, которые применяются параллельно.
- правила могут оперировать единицами глубинного (другое название --- лексическое) представления, поверхностного представления или одновременно обоих.

Например, получить из глубинной формы `spy+s` поверхностную форму `spies`  можно двумя правилами (нотацию мы подробнее обсудим позже):

- `y:i <=> _ 0:e`
- `0:e <=> y: _ %+:`

Первое правило обращается одновременно к глубинному (`0:`) и поверхностному (`:e`) представлениям. Второе правило обращается только к глубинному представлению (`y:`) и поверхностному (`%+:`) представлениям. 

Использование ограничений, вместо правил, чуть позже возникла в фонологии в виде Теории оптимальности (OT, [@prince1994]), однако в рамках OT предпалагаются, что ограничения носят универсальный характер и есть во всех языках, в то время, как ограничения двухуровневой фонологии/морфологии --- имеют частный внутриязыковой характер.

## Программа `twol`

В данном разделе мы будем обсуждать синтаксис `twol`. Данный раздел основан на [@beesley2003].

### Техническое введение

Мы будем использовать программу `hfst-twolc`. Чтобы избежать сложностей на начальных этапах курса, мы решили вначале познакомиться с синтаксисом `twol` и попробовать описывать разные языковые явления, не затрудняя всех установкой и запуском нужных программ у себя на компьютере.

- Для начала работы следует, как и раньше, скачать `Makefile`:

```{{shell}}
$ curl -s https://raw.githubusercontent.com/agricolamz/2025_morphological_transducers/refs/heads/main/task_tests/Makefile -o Makefile; make
```

- дальше, как и раньше, следует создать в колабе или у себя на компьютере (если у вас Linux), файл с названием `task.lexd`. В Google Colab для этого достаточно вставить первой строкой кодового блока `%%writefile task.lexd`. Вот пример такого файла:

```{{lexd}}
PATTERNS
Noun (Suffix[-adj] | (Suffix[adj] Inflection))?

LEXICON Noun
ночь
печь

LEXICON Suffix
<dim>:ка
<adj>:н[adj]

LEXICON Inflection
<m><sg><nom>:ой
```

- нововведением является возможность создания файла с названием `task.twol`, в котором будет содержаться код для обработки (мор)фонологии. Не забудьте вставить `%%writefile task.twol` в Google Colab. Вот пример такого файла:

```{{twol}}
Alphabet
  а е й к н о п ч ь ь:0;

Rules

"чк чн пишется без ь"
! например, ночьной -> ночной или печька -> печка

ь:0 <=> _ к;
        _ н;
```

- После того, как вы установили нужные программы и создали файлы, как и раньше, можно посмотреть формы и разборы, которые генерируются трансдьюсером (не забудьте поставить восклицательный знак перед `make` в Google Colab):

```{{shell}}
$ make forms

ночь<dim>:ночка
ночь<adj><m><sg><nom>:ночной
ночь
печь<dim>:печка
печь<adj><m><sg><nom>:печной
печь
```

- Кроме того можно посмотреть анализ/генерацию конкретных форм (не забудьте поставить восклицательный знак перед `make` в Google Colab):

```{{shell}}
$ make analysis FORM="печка"

hfst-lookup: Warning: It is not possible to perform fast lookups with OpenFST, std arc, tropical semiring format automata.
Using HFST basic transducer format and performing slow lookups
> печка	печь<dim>	0,000000
```

```{{shell}}
$ make generation FORM="ночь<adj><m><sg><nom>"

hfst-lookup: Warning: It is not possible to perform fast lookups with OpenFST, std arc, tropical semiring format automata.
Using HFST basic transducer format and performing slow lookups
> ночь<adj><m><sg><nom>	ночной	0,000000
```

- Как и раньше, получившийся трансдьюсер можно протестировать:

```{{shell}}
$ make test_03_01
```

### Структура `twol` файла

Каждый `twol` файл состоит из нескольких блоков, которые удобно обсуждать на приведенном выше примере:

```{{twol}}
Alphabet                                            # <1>
  а е й к н о п ч ь ь:0;                            # <2>

Rules                                               # <3>

"чк чн пишется без ь"                               # <4>
! например, ночьной -> ночной или печька -> печка   # <5>

ь:0 <=> _ к;                                        # <6>
        _ н;                                        # <7>
```

1. Раздел, которые перечисляет все используемые символы.
2. Декларацией конца раздела является точка с запятой, поэтому иногда удобно писать элементы в несколько строчек, особенно если есть некотрые логические блоки. Из примера видно сокращение: одним символом можно записывать идентичные пары входного и выходного символов (т. е. `й:й` можно записывать как `й`).
3. Раздел с правилами.
4. Название правила (паразительно, но это обязательный элемент [^rule_without_name]).
5. В любом месте файла можно написать комментарий. Начало комментария обозначается восклицательным знаком.
6. Само правило. Оно обычно имеет следующие элементы: какая-то пара входного/выходного символа (`ь:0`), дальше оператор (`<=>`), дальше контекст (`_ к`), все это заканчивается точкой с запятой.
7. Несколько контекстов для одного правила можно записывать вместе. На всякий случай --- отбивка не важна, просто сделал для удобочитаемости.

[^rule_without_name]: Если удалить из работающего файла одно из названий правила получится ошибка, в которой самым явным будет часть сообщения `Error: twol.hfst is not a valid transducer file`.

### Раздел алфавита

Хорошо бы, чтобы раздел алфавита содержал все пары символов (по-английски, symbol pairs или feasible pairs) глубинного и поверхностного представлений, которые представлены в вашем материале. Важно отметить, что `twol` достраивает пары символов из правил, так что программа будет работать и с неполным алфавитом `.twol`. Для нашего примера достаточно следующего файла:

```{{twol}}
Alphabet
  ь;

Rules

"чк чн пишется без ь"

ь:0 <=> _ к;
        _ н;
```

Так как под капотом происходит композиция трансдьюсеров (см. @sec-transducers), то символы, которые не участвуют в правилах `twol`, не будут затронуты. И, единственное, что `twol` не может восстановить, что у нас есть две сущности `ь:0` и `ь:ь`.

Однако все это из разряда вредных советов. Если вы моделируете язык или даже его фрагмент лучше перечислить все символы (и их прописные варианты). Это позволит избежать проблем при анализе некачественных входных данных.

### Архифонемы

Иногда (мор)фонологические проблемы можно решать не постулирая некоторую конкретную сегментную глубинную форму, а используя, так называемые, архифонемы[^archiphoneme]. Эти единицы записываются в `lexd` в фигурных скобках, например `{А}`. Существует конвенция, что если архифонема позже только удаляется, то ее пишут строчными буквами, например, `{s}`, а если архифонема представляет собой набор поверхностных форм, то ее пишут заглавными буквами, например, `{А}`. Важно отметить, что в файле `.twol` фигнурные скобки нужно экранировать при помощи знака процента `%`. Для примера давайте перемоделируем пример из прошлого раздела:

[^archiphoneme]: Этот термин предложил Н. С. Трубецким для единиц, находящихся в слабой фонологической позиции и характеризующихся неполным набором признаковых спецификаций (например, оглушение на конце слова в русском). Однако в практике пользователей `lexc` и `twol` архифонемы --- это просто единицы удобные для моделирования. Иногда их используют и для случаев подразумевавшихся Трубецким, например, для моделирования гармонии, но иногда их используют в качестве для моделирования других морфонологических сложностей.

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
NounStem Inflection

LEXICON NounStem
мама:мам
папа:пап
няня:нян{j}
Таня:Тан{j}

LEXICON Inflection
<nom><sg>:{А}
<gen><sg>:{Ы}
<pos>:ин
```


###### `twol`

```{{twol}}
Alphabet
  а и м н п я Т
  %{А%}:а %{А%}:я %{Ы%}:ы %{Ы%}:и %{j%}:0;

Rules

"удаляем маркер мягкой основы" 

%{j%}:0 <=> _ ;

"гласные после мягкой основы в номинативе" 

%{А%}:я <=> %{j%}:0 _ ;

"гласные после мягкой основы в генетиве" 

%{Ы%}:и <=> %{j%}:0 _ ;
```

###### до применения `twol`

```
мама<nom><sg>:мам{А}
мама<gen><sg>:мам{Ы}
мама<pos>:мамин
папа<nom><sg>:пап{А}
папа<gen><sg>:пап{Ы}
папа<pos>:папин
няня<nom><sg>:нян{j}{А}
няня<gen><sg>:нян{j}{Ы}
няня<pos>:нян{j}ин
Таня<nom><sg>:Тан{j}{А}
Таня<gen><sg>:Тан{j}{Ы}
Таня<pos>:Тан{j}ин  
```

###### после применения `twol`

```
мама<nom><sg>:мама
мама<gen><sg>:мамы
мама<pos>:мамин
папа<nom><sg>:папа
папа<gen><sg>:папы
папа<pos>:папин 
няня<nom><sg>:няня
няня<gen><sg>:няни
няня<pos>:нянин
Таня<nom><sg>:Таня
Таня<gen><sg>:Тани
Таня<pos>:Танин
```

###### старый файл `lexd`

```{{lexd}}
PATTERNS
NounStem[hard] Inflection[hard]
NounStem[soft] Inflection[soft]
NounStem Inflection[-hard,-soft]

LEXICON NounStem
мама:мам[hard]
папа:пап[hard]
няня:нян[soft]
Таня:Тан[soft]

LEXICON Inflection
<nom><sg>:а[hard]
<nom><sg>:я[soft]
<gen><sg>:ы[hard]
<gen><sg>:и[soft]
<pos>:ин
```

:::

Мы видим, что для переходов после мягких основ существует одинаковый контекст, так что можно использовать объединение при помощи оператора `|` (квадратные скобки добавлены для удобочитаемости, работает и без них):

```{{twol}}
Alphabet
  а и м н п я Т
  %{А%}:а %{А%}:я %{Ы%}:ы %{Ы%}:и %{j%}:0;

Rules

"удаляем маркер мягкой основы" 

%{j%}:0 <=> _ ;

"гласные после мягкой основы" 

[ %{А%}:я | %{Ы%}:и ] <=> %{j%}:0 _ ;
```

Также следует обратить внимание, на то, что мы не писали правил для пар `{А}:а` и `{Ы}:ы`. `twol` сам использовал указанные нами переходы во всех контекстах, не специализированным правилом перехода после мягких основ.

Архифонемы позволяют моделировать морфонологические правила, так как мы всегда можем вставить единицу `{some_name}:0`, которая показывает на важную морфонологическую границу, рядом с которой что-то происходит.

::: {.callout-note}

###### Задание 03_02

В работе [@itkin07: 118] описано чередование *н*~*н'* в русском языке. Попробуйте заполнить раздел `Rules` в файле `.twol`, чтобы получился трансдьюсор, моделирующий следующие формы:

| \<nom\>\<sg\> | \<dat\>\<sg\>  | \<ins\>\<pl\>   | \<gen\>\<pl\>  |
|---------------|----------------|-----------------|----------------|
| _башня_       | _башней_       | _башнями_       | _башен_        |
| _песня_       | _песней_       | _песнями_       | _песен_        |
| _бойня_       | _бойней_       | _бойнями_       | _боен_         |
| _деревня_     | _деревней_     | _деревнями_     | _деревень_     |
| _кухня_       | _кухней_       | _кухнями_       | _кухонь_       |
| _Таня_        | _Таней_        | _Танями_        | _Тань_         |

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
(NounRoot NounInfl)[^[hard,soft]]

LEXICON NounRoot
башня<n>:баш{Е}н[hard]
песня<n>:пес{Е}н[hard]
бойня<n>:бой{Е}н[hard]
деревня<n>:дерев{Е}н[soft]
кухня<n>:кух{О}н[soft]
Таня<n>:Тан[soft]

LEXICON NounInfl
<nom><sg>:я
<dat><sg>:ей
<dat><pl>:ями
<gen><pl>:{GEN.PL}[hard]
<gen><pl>:{GEN.PL}ь[soft]
```

###### `twol`

```{{twol}}
Alphabet
    б ш н п с й д р в к х Т м ь
    а я е у и о
    %{Е%}:0 %{О%}:0 %{GEN.PL%}:0 
    %{Е%}:е %{О%}:о
    й:0
;

Rules

```

:::

:::

### Обращение к разным представлениям

Единцы, которыми манипулирует `twol` --- пары глубинного и поверхносного представления. Поэтому в правилах могут появлятся

- полностью определенные единицы, например, `а:ы` или `ь:0`
- единицы, определенные только на одном из представлений
    - глубинном, например, `ы: `
    - поверхностном, например, ` :я`
- placeholder со значением любой знак: ` : ` (еще можно `?`)

### Разделы `Sets` и `Definitions`

Раздел `Sets` --- опциональный раздел `.twol` файла, в котором можно создать группы символов, к которым потом можно обращаться в правилах по имени. Рассмотрим пример моделирования устранение зияния гласных в адыгейском языке [@arkadiev2009: 27--28]:

|         | \<abs\> | 'это не X' <br> \<neg\> | 'это X?' <br> <q> |
|---------|:-------:|:-----------------------:|:-----------------:|
| женщина |  _шъуз_ |        _шъузэп_         |     _шъуза_       |
| мужчина |  _лIы_  |        _лIэп_           |      _лIа_        |
| дом     |  _унэ_  |        _унэп_           |      _уна_        |

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
Root Infl

LEXICON Root
шъуз
лIы
унэ

LEXICON Infl
<abs>:
<neg>:эп
<q>:а
```

###### `twol`

```{{twol}}
Alphabet
    I а з л н п у ш ъ ы э
    а:0 ы:0 э:0;
    
Sets
    Vowels = а ы э;

Rules

"устранение зияния глассных"
Vowels:0 <=> _ Vowels;
```

###### результат

```
лIы<q>:лIа
лIы<neg>:лIэп
лIы<abs>:лIы
унэ<q>:уна
унэ<neg>:унэп
унэ<abs>:унэ
шъуз<abs>:шъуз
шъуз<q>:шъуза
шъуз<neg>:шъузэп
```
:::

Обратим внимание, что `Vowels:0` в рамках нашей задачи можно было бы записать экономичнее `:0`. Однако, такое правило при моделирования большего фрагмента грамматики скорее всего может привести к непредвиденным эффектам. Тем более, что такая запись плохо читаема вне контекста.

Определение множеств может содержать имена множеств, определенных ранее. Все перечисленные в множествах единицы, должны быть определены в разделе `Alphabet`.

Следует отметить, что переменная `Vowels` в нашем `.twol` файле раскрылась всеми возможными способами: `а` -- `а`, `а` -- `ы`, `а` -- `э`, `ы` -- `ы`, `ы` -- `э`, `э` -- `э`.

Раздел `Definitions` --- опциональный раздел `.twol` файла, в котором можно давать некоторым левым или правым контекстам имена, к которым потом можно обращаться в правилах.

### Переменные внутри правил

### Операторы

### Операторы внутри правил

## Примеры чередований

- ассимиляция
- диссимиляция
- гармония
- ослабление
- усиление
- фузия
- расщепление
- элизия
- эпентеза
- чеширизация
- метатеза
- редупликация

## Глоссирование

Все это время анализ, который мы получали содержал исключительно грамматические теги без морфемных границ. Основной разработчик парадигмы правилового морфологического анализа --- Apertium --- скорее заинтересован в создании переводчиков, поэтому морфемные границы отходят на второй план. Однако ожидание большинства лингвистов все же заключаются в том, что морфемные границы в анализе должны быть, так как для них нет другой мотивации вкладываться в работу над морфологическим анализатором, кроме как если у них есть множество неотглоссированных текстов, которые они не хотят глоссировать вручную.

Задача однако в таком случае получается выглядит так:

- На вход мы подаем текст на языке.
- На выходе мы получаем множество пар, где каждый элементы это
    - анализ с поморфемной разбивкой;
    - материал на языке с поморфемной разбивкой.

Отметим, что морфологическая граница традиционно в таких случаях обозначается `>`. Это не самый удобный для читаемости символ, но его ожидают разные другие полезные инструменты на основе трансдьюсеров. Если мы хотим разработать глоссирующий трансдьюсер, нам имеет смысл создавать несколько похожих трансдьюссеров:

- walk\>s --- walk\<v\>\>\<pres\>\<3\>\<sg\>
- walks --- walk\<v\>\>\<pres\>\<3\>\<sg\>

Один от другого отличается одним правилом в `twol`.
