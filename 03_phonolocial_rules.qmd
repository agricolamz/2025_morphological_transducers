# Введение в `twol`: (мор)фонология

## Фонологическое введение

Преобладающая фонологическая теория в XX веке --- генеративная фонология [@chomsky1968]. Согласно этой теории существует два представления: глубинное (underlying/phonological representation) и поверхностное (surface form, phonetic representation). Фонология в этой теории сводится к набору линейено упорядоченных правил, которые применяются циклически, преобразуя результат работы синтаксической деревации в фонетические цепочки.

(@) глубинное представление > фонологическое правило 1 > фонологическое правило 2 > ... > поверхностное представление.

Из-за того, что правила в этой теории строго упорядочены возникают случаи, когда правила взаимодействуют друг с другом. Классификация таких случаев приводится в работе [@kiparsky1982]:

- питающий порядок (feeding). Так называют порядок, при котором применение одного правила увеличивает количество контекстов применение другого правила, так что другое правило срабатывает. [^feeding]
- блокирующий порядок (bleeding). Так называют порядок, при котором применение одного правила уменьшает количество контекстов применения другого правила, так что другое правило не срабатывает. [^bleedong]
- противопитающий порядок (counterfeeding). Так называют порядок, при котором применение одного правила увеличивает
количество контекстов применение другого правила, однако другое правило не срабатывает.
- противоблокирующий порядок (counterbleeding). Так называют порядок, при котором применение одного правила уменьшает
количество контекстов применения другого правила, однако другое правило все равно срабатывает.

[^feeding]: Вот пример питающего порядка из бразильского португальского (индоевропейские).

    | правило       | форма      | транскрипция      | глосса       |
    |---------------|------------|-------------------|--------------|
    | палатализация | bato       | [bá**t**u]        | бить-1sg     |
    | палатализация | bate       | [bá**tʃ**i]       | бить-3sg     |
    | палатализация | ardo       | [áɾ**d**u]        | жечь-1sg     |
    | палатализация | arde       | [áɾ**dʒ**i]       | жечь-3sg     |
    | эпентеза i    | pacto      | [pák**i**tu]      | соглашение   |
    | эпентеза i    | captar     | [kap**i**táɾ]     | взять в плен |
    | эпентеза i    | psicologia | [p**i**sikoloʒíɐ] | психология   |
    
    А вот взаимодействие правил:
    
    |               | /kaptáɾ/ <br> взять в плен | /áɾdi/ <br> жечь-3sg | /advɛ́χsu/ <br> враждебный | /futbɔ́w/ <br> футбол |
    |---------------|:--------------------------:|:--------------------:|:-------------------------:|:--------------------:|
    | эпентеза I    |           kapitáɾ          |          ---         |          adivɛ́χsu         |        futibɔ́w       |
    | палатализация |             ---            |         áɾdʒi        |         adʒivɛ́χsu         |       futʃibɔ́w       |

[^bleedong]: Вот пример питающего порядка из литовского (индоевропейские).

    | правило    | транскрипция         | перевод   |
    |------------|----------------------|-----------|
    | эпентеза i | [at-koːpʲtʲi]        | прийти    |
    | эпентеза i | [atʲ**i**-tʲeisʲtʲi] | присудить |
    | эпентеза i | [ap-kalʲbʲetʲi]      | оговорить |
    | эпентеза i | [apʲ**i**-putʲi]     | подгнить  |
    | озвончение | [at-praʃʲiːtʲi]      | спросить  |
    | озвончение | [a**d**-gautʲi]      | вернуть   |
    | озвончение | [ap-ʃaukjtji]        | объявить  |
    | озвончение | [a**b**-gautji]      | обмануть  |
    
    А вот взаимодействие правил:
    
    |            | /ap-putʲi/ <br> подгнить | /at-gautʲi/ <br> вернуть | /at-duotʲi/ <br> отдать | /ap-bʲekʲtʲi/ <br> обежать |
    |------------|:------------------------:|:------------------------:|:-----------------------:|:--------------------------:|
    | эпентеза i |        apʲi-putʲi        |            ---           |       atʲi-duotʲi       |        apʲi-bʲekʲtʲi       |
    | озвончение |            ---           |         ad-gautʲi        |           ---           |             ---            |


Вот комиксы, которые по нашей задумке должны дополнительно иллюстрировать разницу между разными порядками.

```{r}
#| layout-ncol: 2

knitr::include_graphics("images/03_01_Russita-feeding.png")
knitr::include_graphics("images/03_02_Russita-bleeding.png")
knitr::include_graphics("images/03_03_Russita-counterfeeding.png")
knitr::include_graphics("images/03_04_Russita-counterbleeding.png")
```

## Двухуровневая фонология/морфология

Двухуровневая фонология/морфология (two level morphology) была разработана в диссертации [@koskenniemi1983]. Стоит отметить, что мы используем данный формализм для моделирования (мор)фонологических правил, однако данный формализм называют двухуровневой морфологией (в том числе и сам автор). Вообще, еще в 1972 вышла диссертация [@johnson1972], в которой автор указывал на некоторые недостатки последовательности фонологических правил, которые были приняты в генеративной фонологии, а также доказывал, что любую последовательность правил можно моделировать при помощи трансдьюсера, однако эта работа осталась незамеченной.

В рамках двухуровневой фонологии/морфологии:

- правила --- посимвольные ограничения на поверхностное представление, которые применяются параллельно.
- правила могут оперировать единицами глубинного (другое название --- лексическое) представления, поверхностного представления или одновременно обоих.

Например, получить из глубинной формы `spy+s` поверхностную форму `spies`  можно двумя правилами (нотацию мы подробнее обсудим позже):

- `y:i <=> _ 0:e`
- `0:e <=> y: _ %+:`

Первое правило обращается одновременно к глубинному (`0:`) и поверхностному (`:e`) представлениям. Второе правило обращается только к глубинному представлению (`y:`) и поверхностному (`%+:`) представлениям. 

Использование ограничений, вместо правил, чуть позже возникла в фонологии в виде Теории оптимальности (OT, [@prince1994]), однако в рамках OT предпалагаются, что ограничения носят универсальный характер и есть во всех языках, в то время, как ограничения двухуровневой фонологии/морфологии --- имеют частный внутриязыковой характер.

## Программа `twol`

В данном разделе мы будем обсуждать синтаксис `twol`. Данный раздел основан на [@beesley2003].

### Техническое введение

Мы будем использовать программу `hfst-twolc`. Чтобы избежать сложностей на начальных этапах курса, мы решили вначале познакомиться с синтаксисом `twol` и попробовать описывать разные языковые явления, не затрудняя всех установкой и запуском нужных программ у себя на компьютере.

- Для начала работы следует, как и раньше, скачать `Makefile`:

```{{shell}}
$ curl -s https://raw.githubusercontent.com/agricolamz/2025_morphological_transducers/refs/heads/main/task_tests/Makefile -o Makefile; make
```

- дальше, как и раньше, следует создадать в коллабе или у себя на компьютере (если у вас Linux), файл с названием `task.lexd`. В Google Colab для этого достаточно вставить первой строкой кодового блока `%%writefile task.lexd`. Вот пример такого файла:

```{{lexd}}
PATTERNS
Noun (Suffix[-adj] | (Suffix[adj] Inflection))?

LEXICON Noun
ночь
печь

LEXICON Suffix
<dim>:ка
<adj>:н[adj]

LEXICON Inflection
<m><sg><nom>:ой
```

- нововведением является возможность создания файла с названием `task.twol`, в котором будет содержаться код для обработки (мор)фонологии. Не забудьте вставить `%%writefile task.twol` в Google Colab. Вот пример такого файла:

```{{twol}}
Alphabet
  а е й к н о п ч ь ь:0;

Rules

"чк чн пишется без ь"
! например, ночьной -> ночной или печька -> печка

ь:0 <=> _ к;
        _ н;
```

- После того, как вы установили нужные программы и создали файлы, как и раньше, можно посмотреть формы и разборы, которые генерируются трансдьюсером (не забудьте поставить восклицательный знак перед `make` в Google Colab):

```{{shell}}
$ make forms

ночь<dim>:ночка
ночь<adj><m><sg><nom>:ночной
ночь
печь<dim>:печка
печь<adj><m><sg><nom>:печной
печь
```

- Кроме того можно посмотреть анализ/генерацию конкретных форм (не забудьте поставить восклицательный знак перед `make` в Google Colab):

```{{shell}}
$ make analysis FORM="печка"

hfst-lookup: Warning: It is not possible to perform fast lookups with OpenFST, std arc, tropical semiring format automata.
Using HFST basic transducer format and performing slow lookups
> печка	печь<dim>	0,000000
```

```{{shell}}
$ make generation FORM="ночь<adj><m><sg><nom>"

hfst-lookup: Warning: It is not possible to perform fast lookups with OpenFST, std arc, tropical semiring format automata.
Using HFST basic transducer format and performing slow lookups
> ночь<adj><m><sg><nom>	ночной	0,000000
```

- Как и раньше, получившийся трансдьюсер можно протестировать:

```{{shell}}
$ make test_03_01
```

### Структура `twol` файла

Каждый `twol` файл состоит из нескольких блоков, которые удобно обсуждать на приведенном выше примере:

```{{twol}}
Alphabet                                            # <1>
  а е й к н о п ч ь ь:0;                            # <2>

Rules                                               # <3>

"чк чн пишется без ь"                               # <4>
! например, ночьной -> ночной или печька -> печка   # <5>

ь:0 <=> _ к;                                        # <6>
        _ н;                                        # <7>
```

1. Раздел, которые перечисляет все используемые символы.
2. Декларацией конца раздела является точка с запятой, поэтому иногда удобно писать элементы в несколько строчек, особенно если есть некотрые логические блоки. Из примера видно сокращение: одним символом можно записывать идентичные пары входного и выходного символов (т. е. `й:й` можно записывать как `й`).
3. Раздел с правилами.
4. Название правила (паразительно, но это обязательный элемент).
5. В любом месте файла можно написать комментарий. Начало комментария обозначается восклицательным знаком.
6. Само правило. Оно обычно имеет следующие элементы: какая-то пара вхохдного/выходного символа (`ь:0`), дальше оператор (`<=>`), дальше контекст (`_ к`), все это заканчивается точкой с запятой.
7. Несколько контекстов для одного правила можно записывать вместе.

### Раздел алфавита

Хорошо бы, чтобы раздел алфавита содержал все пары символов (по-английски, symbol pairs или feasible pairs) глубинного и поверхностного представлений, которые представлены в вашем материале. Важно отметить, что `twol` достраивает пары символов из правил, так что программа будет работать и с неполным алфавитом `.twol`. Для нашего примера достаточно следующего файла:

```{{twol}}
Alphabet
  ь;

Rules

"чк чн пишется без ь"

ь:0 <=> _ к;
        _ н;
```

Так как под капотом происходит композиция трансдьюсеров (см. @sec-transducers), то символы, которые не участвуют в правилах `twol` не будут затронуты. И, единственное, что `twol` не может восстановить, что у нас есть две сущности `ь:0` и `ь:ь`.

Однако все это из разделов вредных советов. Если вы моделируете язык или даже его фрагмент лучше перечислить все символы (и их прописные варианты). Это позволит избежать проблем при анализе некачественных входных данных.

### Гиперфонемы

::: {.callout-note}

###### Задание 03_03

В [@itkin07: 118] описывается чередование *н*~*н'* в русском языке. Попробуйте написать трансдьюсор, моделирующий следующие формы:  

| nom.sg    | dat.sg     | ins.pl      | gen.pl     |
|-----------|------------|-------------|------------|
| _башня_   | _башней_   | _башнями_   | _башен_    |
| _песня_   | _песней_   | _песнями_   | _песен_    |
| _бойня_   | _бойней_   | _бойнями_   | _боен_     |
| _деревня_ | _деревней_ | _деревнями_ | _деревень_ |
| _кухня_   | _кухней_   | _кухнями_   | _кухонь_   |
| _Таня_    | _Таней_    | _Танями_    | _Тань_     |

:::

## Примеры чередований

- ассимиляция
- диссимиляция
- гармония
- ослабление
- усиление
- фузия
- расщепление
- элизия
- эпентеза
- чеширизация
- метатеза
- редупликация
