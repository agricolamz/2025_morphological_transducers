# Введение в `lexd`

## Техническое введение

В данном разделе мы обсуждаем синтаксис программы [`lexd`](https://github.com/apertium/lexd/blob/main/Usage.md) [@swanson21]. Данная программа работает в связке 

- с бесплатным програмным обеспечением с открытым исходным кодом Helsinki Finite-State Tookit `hfst` [@linden11];
- аналогичным инструментом от Apertium `lttoolbox` [@ortiz05].

Это консольная программа, работающая на юниксоподобных системах. Чтобы избежать сложностей на начальных этапах курса, мы решили вначале познакомиться с синтаксисом `lexd` и попробовать описывать разные языковые явления, не затрудняя всех установкой и запуском у себя на компьютере. В связи с этим мы предлагаем выучить следующие четыре команды, которые будут работать на операционных системах Linux, основанных на Debian/Ubuntu, и в Google Colab:

- скачиваем инструкции для установки `lexd` и `hfst` и дальнейшей работы с ними, записанные в простом текстовом файле, которые можно прочитать, если открыть [ссылку](https://shorturl.at/0bBXE) из команды. Команда `make` запускает установку. Для того, чтобы это работало в Google Colab нужно перед командой нужно поставить восклицательный знак: `!curl ...`. Знак доллара означает, что дальше следует команда командной строки, не надо его никуда копировать.

```{{shell}}
$ curl https://raw.githubusercontent.com/agricolamz/2025_morphological_transducers/refs/heads/main/task_tests/Makefile -o Makefile; make
```

- дальше мы ожидаем, что вы создадите в коллабе или у себя на компьютере (если у вас Linux), файл с названием `task.lexd`. В Google Colab для этого достаточно вставить первой строкой кодового блока `%%writefile task.lexd`. Вот пример такого файла:

```{{lexd}}
PATTERNS
VerbRoot VerbInfl

LEXICON VerbRoot
sing<v>:sing
walk<v>:walk
dance<v>:dance

LEXICON VerbInfl
<pres>:
<pres><3><sg>:s
```

- После того, как вы установили нужные программы и создали файл, можно посмотреть формы и разборы, которые генерируются трансдьюсером. Это можно сделать следующей командой (не забудьте поставить восклицательный знак перед `make` в Google Colab):

```{{shell}}
$ make forms

sing<v><pres>:sing
sing<v><pres><3><sg>:sings
walk<v><pres>:walk
walk<v><pres><3><sg>:walks
dance<v><pres>:dance
dance<v><pres><3><sg>:dances
```

- В ходе курса мы будем разбирать разные лингвистические задачи. У каждой задачи есть номер и автоматический тест, который его проверяет. Чтобы запустить автоматическую проверку, следует ввести команду, где первое число -- номер раздела, а второе число -- номер задачи. Например, для того, чтобы проверить, работает ли проверка задания, попробуйте запустить следующую команду:

```{{shell}}
$ make test_02_01
```

- Чтобы окончательно посмотреть все варианты, попробуйте изменить последнюю строчку файла `task.lexd` на `<pres><3><sg>:S` и снова перезапустить команду:

```{{shell}}
$ make test_02_01
```

## Программа `lexd`

У программы `lexd` есть подробный [туториал](https://github.com/apertium/lexd/blob/main/Usage.md), так что данный раздел во многом опирается на него. Давайте подробнее рассмотрим `lexd` файл, который мы видели в прошлом разделе:

```{{lexd}}
PATTERNS            # <1>
VerbRoot VerbInfl   

LEXICON VerbRoot    # <2>
sing<v>:sing        # <3>
walk<v>:walk
dance<v>:dance

LEXICON VerbInfl    # <4>
<pres>:             # <5>
<pres><3><sg>:s     # <6>
```

1. Обязательный раздел `PATTERNS`, в котором каждая строка сообщает, как могут соединяться элементы из разных групп лексикона.
2. Группа лексикона, которая состоит из слова `LEXICON` и имени, под которым данная группа появляется в разделе `PATTERNS`
3. Наполнение группы. Первым идет разбор, а потом после двоеточия языковой материал. Морфологические теги принято записывать в треугольных скобках.
4. Вторая группа `LEXICON` и ее имя.
5. Пример нулевой морфемы.
6. Пример морфемы с несколькими морфологическими тегами.

Отметим, что можно создавать свои именнованные подразделы `PATTERN`, которые потом можно использовать в разделе `PATTERNS`, например:

```{{lexd}}
PATTERNS
VerbStem Tense PersonNumber

PATTERN VerbStem            # <1>
VerbRoot
VerbRoot Causative

LEXICON VerbRoot
...

LEXICON Causative
...

LEXICON Tense 
...

LEXICON PersonNumber
...
```

1. Именованный раздел `PATTERN`, который используется потом в разделе `PATTERNS`.

Таким образом, в каждом файле `lexd` должен быть раздел `PATTERNS`, содержащий в себе переменные, которые могут быть заданы либо в разделе `PATTERN`, либо в разделе `LEXICON`, либо их анонимные варианты (см. раздел @sec-anonymous). Также разные разделы можно переименовывать при помощи группы `ALIAS` (см. мануал). Комментарии можно оформлять при помощи хештега `#`.

::: {.callout-note}

###### Задание 02_02 

Ниже представлен фрагмент ицаринской (даргинские, нахско-дагестанские) парадигмы из [@sumbatova03]. Попробуйте смоделировать ее при помощи `lexd`. Для корректного моделирования формы sup.lat нужна морфонология, так что при моделировании используйте форму в скобках. При моделировании придется покривить душой: *-b* в формах ess и dir --- инфикс классного показателя. Помните, что каждый морфологический тег следует обрамлять в отдельные треугольные скобки, например, `sːika<n><ant><dir>:sːikasabal`. Для ориентации в нашем lexd файле 26 строк.

| форма    | козел                    | медведь                |
|----------|--------------------------|------------------------|
| abs      | _q’atsa_                 | _sːika_                |
| erg      | _q’atsal_                | _sːikal_               |
| gen      | _q’atsala_               | _sːikala_              |
| com      | _q’atsatsːilli_          | _sːikatsːilli_         |
| sup.lat  | _q’atsaj_ (< _q’atsaji_) | _sːikaj_ (< _sːikaji)_ |
| sup.ess  | _q’atsajib_              | _sːikajib_             |
| sup.dir  | _q’atsajibal_            | _sːikajibal_           |
| sup.el   | _q’atsajir_              | _sːikajir_             |
| sub.lat  | _q’atsaʁu_               | _sːikaʁu_              |
| sub.ess  | _q’atsaʁub_              | _sːikaʁub_             |
| sub.dir  | _q’atsaʁubal_            | _sːikaʁubal_           |
| sub.el   | _q’atsaʁur_              | _sːikaʁur_             |
| ant.lat  | _q’atsasa_               | _sːikasa_              |
| ant.ess  | _q’atsasab_              | _sːikasab_             |
| ant.dir  | _q’atsasabal_            | _sːikasabal_           |
| ant.el   | _q’atsasar_              | _sːikasar_             |
| post.lat | _q’atsaha_               | _sːikaha_              |
| post.ess | _q’atsahab_              | _sːikahab_             |
| post.dir | _q’atsahabal_            | _sːikahabal_           |
| post.el  | _q’atsahar_              | _sːikahar_             |
| in.lat   | _q’atsatsːi_             | _sːikatsːi_            |
| in.ess   | _q’atsatsːib_            | _sːikatsːib_           |
| in.dir   | _q’atsatsːibal_          | _sːikatsːibal_         |
| in.el    | _q’atsatsːir_            | _sːikatsːir_           |

:::

### Операторы

Квантификация напоминает регулярные выражения:

- `?` --- ноль или один раз
- `*` --- ноль и более раз [^why_star]
- `+` --- один и более раз

[^why_star]: Мы какое-то время думали, зачем это может быть нужно и придумали только странные сценарии типа *пра-пра-пра-пра-бабушка*. Но вообще это порождает циклы, от которых одни проблемы.

::: {.panel-tabset}

###### с оператором

```{{lexd}}
PATTERNS
Root Negation?

LEXICON Root
...

LEXICON Negation
...
```

###### без оператора

```{{lexd}}
PATTERNS
Root
Root Negation

LEXICON Root
...

LEXICON Negation
...
```

:::

- `|` --- оператор или (можно с пробелами вокруг)

::: {.panel-tabset}

###### с оператором

```{{lexd}}
PATTERNS
Root PastInflection|PresentInflection

LEXICON Root
...

LEXICON PastInflection
...

LEXICON PresentInflection
...
```

###### без оператора

```{{lexd}}
PATTERNS
Root PastInflection
Root PresentInflection

LEXICON Root
...

LEXICON PastInflection
...

LEXICON PresentInflection
...
```

:::

- Кроме того есть операторы, названные в матералах `lexd` ситом, `>` и `<`:

::: {.panel-tabset}

###### с оператором

```{{lexd}}
PATTERNS
VerbRoot > TAM > CLITICS

LEXICON Root
...

LEXICON TAM
...

LEXICON CLITICS
...
```

###### без оператора

```{{lexd}}
PATTERNS
VerbRoot
VerbRoot TAM
VerbRoot TAM CLITICS

LEXICON Root
...

LEXICON TAM
...

LEXICON CLITICS
...
```

:::

### Анонимные разделы {#sec-anonymous}

Некоторые фрагменты аннотации можно вставлять прямо в раздел `PATTERNS`. Для этого используются квадртные скобки.

::: {.panel-tabset}

###### сокращенный вариант

```{{lexd}}
PATTERNS
NounStem [<n>:] NounNumber

LEXICON NounStem
sock
ninja

LEXICON NounNumber
<sg>:
<pl>:s
```

###### развернутый вариант 1

```{{lexd}}
PATTERNS
NounStem NounNumber

LEXICON NounStem
sock<n>:sock
ninja<n>:ninja

LEXICON NounNumber
<sg>:
<pl>:s
```

###### развернутый вариант 2

```{{lexd}}
PATTERNS
NounStem NounTag NounNumber

LEXICON NounTag             # <1>
<n>:

LEXICON NounStem
sock
ninja

LEXICON NounNumber
<sg>:
<pl>:s
```

1. Новый раздел `LEXICON`.

:::

В мануале это трюк назван *Anonymous LEXICON*, видимо, потому что предполагается, что мы таким образом избегаем создания дополнительного раздела `LEXICON` (см. развернутый пример 2).

По аналогии с анонимным разделом `LEXICON` есть анонимный раздел `PATTERN`. Для этого используются круглые скобки.

::: {.panel-tabset}

###### сокращенный вариант

```{{lexd}}
PATTERNS
(VerbRoot Causative?) | AuxRoot Tense PersonNumber

LEXICON VerbRoot
...

LEXICON Causative
...

LEXICON AuxRoot
...

LEXICON Tense 
...

LEXICON PersonNumber
...
```

###### развернутый вариант

```{{lexd}}
PATTERNS
VerbStem | AuxRoot Tense PersonNumber

PATTERN VerbStem              # <1>
VerbRoot Causative?

LEXICON VerbRoot
...

LEXICON Causative
...

LEXICON AuxRoot
...

LEXICON Tense 
...

LEXICON PersonNumber
...
```

1. Новый раздел `PATTERN`.

:::

### Теги

На содержимое разделов `LEXICON` можно вешать теги. Это может быть полезно, например, для моделирования словоизменительных классов. Рассмотрим пример из русского языка (славянские, индоевропейские):

```{{lexd}}
PATTERNS
NounStem[hard] Inflection[hard]
NounStem[soft] Inflection[soft]

LEXICON NounStem
мама:мам[hard]
папа:пап[hard]
няня:нян[soft]
Таня:Тан[soft]

LEXICON Inflection
<nom><sg>:а[hard]
<nom><sg>:я[soft]
<gen><sg>:ы[hard]
<gen><sg>:и[soft]
```

То же самое можно записать при помощи одного тега, используя операцию отмены тега:

```{{lexd}}
PATTERNS
NounStem[hard] Inflection[hard]
NounStem[-hard] Inflection[-hard]

LEXICON NounStem
мама:мам[hard]
папа:пап[hard]
няня:нян
буря:бур

LEXICON Inflection
<nom><sg>:а[hard]
<nom><sg>:я
<gen><sg>:ы[hard]
<gen><sg>:и
```

Однако в русском языке можно найти аффиксы, которые присоединяются к обоим типам основ, в таком случае, придется усложнить наше описание:

```{{lexd}}
PATTERNS
NounStem[hard] Inflection[hard]
NounStem[soft] Inflection[soft]
NounStem Inflection[-hard,-soft]

LEXICON NounStem
мама:мам[hard]
папа:пап[hard]
няня:нян[soft]
Таня:Тан[soft]

LEXICON Inflection
<nom><sg>:а[hard]
<nom><sg>:я[soft]
<gen><sg>:ы[hard]
<gen><sg>:и[soft]
<pos>:ин
```

Авторы `lexd` добавили возможность взаимодействия тегов, чтобы не надо было писать одно и то же.

- `(A B)[x]  = (A[x] B) | (A B[x])`

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
(A B)[x]

LEXICON A
aaa[x]
bbb

LEXICON B
AAA[x]
BBB
```

###### результат

```
aaaAAA
aaaBBB
bbbAAA
```
:::

- `(A B)[-x] = A[-x] B[-x]`

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
(A B)[-x]

LEXICON A
aaa[x]
bbb

LEXICON B
AAA[x]
BBB
```

###### результат

```
bbbBBB
```
:::

- `A[|[x,y]] = A[x] | A[y]`

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
A[|[x,y]]

LEXICON A
aaa[x]
bbb[y]
ccc
```

###### результат

```
aaa
bbb
```
:::

- `A[^[x,y]] = A[x,-y] | A[-x,y]`

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
A[^[x,y]]

LEXICON A
aaa[x]
bbb[y]
ccc[z]
ddd[x,y]
eee[x,z]
fff[y,z]
```

###### результат

```
aaa
eee
bbb
fff 
```
:::

`^` --- очень полезный оператор, который позволяет смоделировать наш русский пример одной строчкой:

::: {.panel-tabset}

###### с оператором

```{{lexd}}
PATTERNS
(NounStem Inflection)[^[hard,soft]]

LEXICON NounStem
мама:мам[hard]
папа:пап[hard]
няня:нян[soft]
Таня:Тан[soft]

LEXICON Inflection
<nom><sg>:а[hard]
<nom><sg>:я[soft]
<gen><sg>:ы[hard]
<gen><sg>:и[soft]
<pos>:ин
```

###### старый вариант

```{{lexd}}
PATTERNS
NounStem[hard] Inflection[hard]
NounStem[soft] Inflection[soft]
NounStem Inflection[-hard,-soft]

LEXICON NounStem
мама:мам[hard]
папа:пап[hard]
няня:нян[soft]
Таня:Тан[soft]

LEXICON Inflection
<nom><sg>:а[hard]
<nom><sg>:я[soft]
<gen><sg>:ы[hard]
<gen><sg>:и[soft]
<pos>:ин
```
:::


::: {.callout-note}

###### Задание 02_03

Ниже представлен фрагмент финской (фино-угорские, уральские) парадигмы [@karlsson13], как видно, здесь слова двух словоизменительных типов. Попробуйте смоделировать представленную парадигму, используя теги.

| glosses   | зал       | общежитие     | дверь    | зима       |
|-----------|-----------|---------------|----------|------------|
| nom.sg    | _sali_    | _hostelli_    | _ovi_    | _talvi_    |
| acc.sg    | _sali_    | _hostelli_    | _ovi_    | _talvi_    |
| gen.sg    | _salin_   | _hostellin_   | _oven_   | _talven_   |
| prt.sg    | _salia_   | _hostellia_   | _ovea_   | _talvea_   |
| in.ess.sg | _salissa_ | _hostellissa_ | _ovessa_ | _talvessa_ |
| in.abl.sg | _salista_ | _hostellista_ | _ovesta_ | _talvesta_ |
| at.ess.sg | _salilla_ | _hostellilla_ | _ovella_ | _talvella_ |
| at.abl.sg | _salilta_ | _hostellilta_ | _ovelta_ | _talvelta_ |
| at.all.sg | _salille_ | _hostellille_ | _ovelle_ | _talvelle_ |
| frml.sg   | _salina_  | _hostellina_  | _ovena_  | _talvena_  |
| trans.sg  | _saliksi_ | _hostelliksi_ | _oveksi_ | _talveksi_ |
| priv.sg   | _salitta_ | _hostellitta_ | _ovetta_ | _talvetta_ |

:::

### Моделирование разрывных морфем: инфиксы, редупликация, семитские корни

В разеделе `PATTERNS` можно перечислять разные стороны единиц (или входное и выходное значение), записанных в `LEXICON`. Это позволяет 

- опускать либо глоссы, либо морфемы (полезно для моделирования редупликации);
- иметь разный порядок глосс и морфем (но зачем?).

Вот пример моделирования дистрибутивных числительных (т. е. числительных со значением 'по Х') в зиловском андийском (андийские, нахско-дагестанские):

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
Numerals NumeralMarker
NumeralReduplication :Numerals Numerals NumeralDistributiveMarker

LEXICON Numerals
чIе               # числительное 2
лъоб              # числительное 3
ойлIи             # числительное 6

LEXICON NumeralMarker
<num>:гу

LEXICON NumeralDistributiveMarker
<distr>:

LEXICON NumeralReduplication
<rdp>:
```

###### результат

```
чIе<num>:чIегу
лъоб<num>:лъобгу
ойлIи<num>:ойлIигу
<rdp>чIе<num><distr>:чIечIегу
<rdp>лъоб<num><distr>:лъоблъобгу
<rdp>ойлIи<num><distr>:ойлIиойлIигу
```
:::

Кроме того для моделирования разрывных морфем, вводится номер в круглых скобках, а элементы морфемы перечисляются через пробел. Вот пример, из иврита (симитские, афразийские):

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
C(1) V(1) C(2) :V(2) C(3) V(2):

LEXICON C(3)
sh m r          # соблюдать, защищать
y sh v          # садиться

LEXICON V(2)
:a <v><p3><sg>:a
:o <v><pprs>:e
```

###### результат

```
shmr<v><p3><sg>:shamar
shmr<v><pprs>:shomer
yshb<v><p3><sg>:yashab
yshb<v><pprs>:yosheb
```
:::

::: {.callout-note}

###### Задание 02_04

Ниже дан фрагмент парадигмы слова 'каждый' в гагатлинском диалекте андийского языка (андийские, нахско-дагестанские) [@salimov2010]. Попробуйте смоделировать в `lexd` представленную парадигму. Наши ожидания от разбора: `живжив<inan2><ad><ell><pl>:жирожиролихакку`.

| глоссы    | m                 | f                 | an                | inan1             | inan2             |
|-----------|-------------------|-------------------|-------------------|-------------------|-------------------|
| abs.sg    | _живжив_          | _жийжий_          | _жибжиб_          | _жибжиб_          | _жиржир_          |
| abs.pl    | _живоживол_       | _жийожийол_       | _жийожийол_       | _жибожибол_       | _жирожирол_       |
| erg.sg    | _живжившди_       | _жийжийдди_       | _жибжибдди_       | _жибжибдди_       | _жиржирдди_       |
| erg.pl    | _живоживолуди_    | _жийожийолиди_    | _жийожийолиди_    | _жибожиболиди_    | _жирожиролиди_    |
| gen.sg    | _живживщув_       | _жийжийлIи_       | _жибжиблIи_       | _жибжиблIи_       | _жиржирлIи_       |
| gen.pl    | _живоживолув_     | _жийожийолилIи_   | _жийожийолилIи_   | _жибожиболилIи_   | _жирожиролилIи_   |
| in.ess.sg | _живжившла_       | _жийжийла_        | _жибжибла_        | _жибжибла_        | _жиржирла_        |
| in.ess.pl | _живоживолула_    | _жийожийолила_    | _жийожийолила_    | _жибожиболила_    | _жирожиролила_    |
| in.lat.sg | _живжившло_       | _жийжийло_        | _жибжибло_        | _жибжибло_        | _жиржирло_        |
| in.lat.pl | _живоживолуло_    | _жийожийолило_    | _жийожийолило_    | _жибожиболило_    | _жирожиролило_    |
| in.ell.sg | _живжившлакку_    | _жийжийлакку_     | _жибжиблакку_     | _жибжиблакку_     | _жиржирлакку_     |
| in.ell.pl | _живоживолулакку_ | _жийожийолилакку_ | _жийожийолилакку_ | _жибожиболилакку_ | _жирожиролилакку_ |
| ad.ess.sg | _живжившха_       | _жийжийха_        | _жибжибха_        | _жибжибха_        | _жиржирха_        |
| ad.ess.pl | _живоживолуха_    | _жийожийолиха_    | _жийожийолиха_    | _жибожиболиха_    | _жирожиролиха_    |
| ad.lat.sg | _живжившхо_       | _жийжийхо_        | _жибжибхо_        | _жибжибхо_        | _жиржирхо_        |
| ad.lat.pl | _живоживолухо_    | _жийожийолихо_    | _жийожийолихо_    | _жибожиболихо_    | _жирожиролихо_    |
| ad.ell.sg | _живжившхтакку_   | _жийжийхакку_     | _жибжибхакку_     | _жибжибхакку_     | _жиржирхакку_     |
| ad.ell.pl | _живоживолухакку_ | _жийожийолихакку_ | _жийожийолихакку_ | _жибожиболихакку_ | _жирожиролихакку_ |

:::

### Регулярные выражения
