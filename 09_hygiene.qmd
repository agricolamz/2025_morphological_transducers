# Как распространять работу?

Существует достаточно много причин, по которой необходимо уметь распространять свою работу:

- **Резервное копирование**. Хранить свою работу в одном месте достаточно недальновидно: компьютеры ломаются, ноутбуки крадут, да и люди (а теперь и набирающие популярность LLM-агенты) могут сделать ошибку, которая приведет к потере данных.
- **Возможность совместной работы**. Разместив проект в некотором общедоступном месте, вы значительно облегчите совместную разработку.
- **Возможность получить обратную связь и помощь**. Разместив проект в некотором общедоступном месте, вы значительно облегчите другим процесс оценки вашей работы. Не говоря уже о том, что общедоступный проект может привлечь внимание некоторого стороннего разработчика, который захочет как-то улучшить проект.
- **История изменения**. Все современные системы для работы с кодом, поддерживают в том или ином виде историю изменений. Иногда это делают даже облачные системы, которые раз в некоторое время синхронизируются с вашей файловой системой. Это очень полезно, так как позволяет вернутся на несколько шагов назад, если с вашим процессом разработки пошло что-то не так.
- **Запуск сервиса**. Если хочется сделать сервис, чтобы люди в мире могли пользоваться результатами вашего труда, имеет смысл сделать так, чтобы вашу работу можно было скачать и установить на отдельном сервере (контейнере и т. п.).

## Введение в `git`

```{r}
#| out-width: 40%
#| fig-cap: "источник: https://xkcd.com/1597/"
#| fig-align: center

knitr::include_graphics("images/09_01_xkcd.png")
```

## Cимволы подстановки (wildcards)

Как и во многих языках программирования командная строка поддерживает символы подстановки. Хоть я приведу все примеры с программой `ls`, легко представить себе и более осмысленные задачи. Для примера, представим, что у нас есть папка с большим количеством файлов:

```{{shell}}
$ ls multiple_files
```

```{r}
system("ls examples/multiple_files", intern = TRUE) |> 
  cat(sep = "\n")
```

Мы можем вывести все файлы содержащие двойку, добавив `*` -- любое количество символов:

```{{shell}}
$ ls multiple_files/*2*
```

```{r}
system("ls examples/multiple_files/*2*", intern = TRUE) |> 
  cat(sep = "\n")
```

Это же используют для поиска файлов с каким-либо определенным расширением:

```{{shell}}
$ ls multiple_files/*.csv
```

```{r}
system("ls examples/multiple_files/*.csv", intern = TRUE) |> 
  cat(sep = "\n")
```

Кроме того звездочку можно использовать и без каких либо окружающих символов, тогда будут перечислены все файлы. Например, следующий команда удаляет все файлы в папке `multiple_files`.

```{{shell}}
$ rm multiple_files/*
```

Если известно точное количество символов, то можно использовать символ `?`, который обозначает один символ. Выведем только файлы с четырьмя символами до расширения:

```{{shell}}
$ ls multiple_files/????.*
```

```{r}
system("ls examples/multiple_files/????.*", intern = TRUE) |> 
  cat(sep = "\n")
```

Искать можно и по расширению:

```{{shell}}
$ ls multiple_files/a_1.???
```

```{r}
system("ls examples/multiple_files/a_1.???", intern = TRUE) |> 
  cat(sep = "\n")
```

Кроме того можно задавать группы при помощи квадратных скобок:

```{{shell}}
$ ls multiple_files/[aouie]*
```

```{r}
system("ls examples/multiple_files/[aouie]*", intern = TRUE) |> 
  cat(sep = "\n")
```

## `.gitignore`

Символы подстановки очень полезны при создании файла `.gitignore`. `.gitignore` --- это специальный скрытый файл[^hidden], в котором вы можете перечислить файлы, которые программа `git` должна игнорировать (см. [документацию](https://git-scm.com/docs/gitignore)). 

[^hidden]: Скрытые файлы или папки начинаются с точки и не высвечиваются по команде `ls` (но высвечиваются по команде `ls -a`). Скрытые файлы часто хранят конфигурационные файлы или какие данные, которые используют программы. Эта категория файлов создано, чтобы пользователь случайно не переписал или удалил какой-то из файлов. 

При создании морфологического анализатора достаточно обмениваться файлами `.lexd`, `.twol`, `.cg3` и инструкциями по компиляции анализатора, которые обычно записывают в `Makefile` (см. раздел @sec-makefile). Получающиеся файлы вроде `.hfst` или `.hfstol` хотелось бы случайно не закоммитить на GitHub. В связи с этим в вашем репозитории имеет смысл перечислить файлы, которые следует игнорировать версии контроля. Вот как будет выглядеть такой файл `.gitignore`:

```
*.hfst
*.hfstol
```

Позже может так случится, что вы будете хранить в той же папке литературу и/или данные, которые нельзя выкладывать, их тоже можно будет добавить в файл `.gitignore`. Кроме того у GitHub есть ограничения на размер файла (вроде 100мб?..), если он увидит большие файлы, то он не даст их добавить, так что если они есть в вашем проекте, их тоже следует добавить в `.gitignore`.

## `git hooks`

## Команда `make` {#sec-makefile}
