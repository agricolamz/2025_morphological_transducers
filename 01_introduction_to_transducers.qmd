---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Автоматический морфологический анализ

Морфологический анализ, как его обычно видят лингвисты, обычно включает в себя несколько вещей:

- определение морфологической формы (например, латинское *mensam* --- [acc.sg]{.smallcaps});
- приведение к начальной форме или основе (*mensam* --- *mensa*, ж. р., первое склонение);
- перевод основы (*mensam* --- 'стол').

В зависимости от целей люди делают акцент на разные аспекты морфологического анализа. Для многих NLP задач полезным является приведение к начальной форме, лингвистический корпусной анализ практически невозможен без заранее определенных морфологических форм, и все три необходимы для представления языкового материала в научной работе. Также стоит помнить, что для разных целей могут быть важны разные категории: например, для согласования может быть важна несловоизменительная для существительных (чаще всего) категория рода.

## Приведение к основе (stemming)

Достаточно широкое применение в ранюю эпоху NLP получили методы, которые позволяют привести словоформы к основе или квазиоснове. Эта процедура помогала уменьшить разнообразие форм в тексте, что облегчало поиск и извлечение информации.

TBC

[@porter80]

[@singh17]

## Много данных

Обычно, если много данных, люди используют нейросети. Для морфологического анализа русского языка их использовали в следующих работах [@arefyev18; @sorokin18; @bolshakova19a; @bolshakova19b; @bolshakova20; @garipov23]. Используются разные архитектуры:

- cвёрточные нейронные сеть (convolutional neural network, CNN);
- деревья решения с градиентным бустингом (decision trees with gradient boosting);
- двунаправленная длинная цепь элементов краткосрочной памяти (Biderectional long short-term memory network, Bi-LSTM);
- и другие.

Другой важный проект, который можно упомянуть в этом разделе: [UDPipe](https://ufal.mff.cuni.cz/udpipe/2) --- проект, основанный на размечанных в формате [Universal Dependencies трибанках](https://universaldependencies.org/) большого количества языков  [@straka18]. Отметим, что их задача амбициознее: они строят модель, совмещающая морфологический парсер и синтаксический парсер дерева зависимостей. Внутри: длинная цепь элементов краткосрочной памяти (LSTM), которая работает на основе векторного представления слов.

Также стоит упомянуть проект [Morfessor](http://morpho.aalto.fi/projects/morpho/), в котором используют скрытые марковские цепи (HMM) [@gronroos14].

## Морфологические трансдьюссеры

### Конечные автоматы

Теория автоматов --- это дисциплина на стыке математики и компьютерных наук, которая появилась в XX веке. Первые конечных автоматов были предложены в работах [@mealy55; @moore56].

Под автоматами мы понимаем абстрактные машины, которые принимают разные состояния, а изменение состояний вызывается некоторым действием:

```{r}
#| eval: false

library(DiagrammeR)
grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=18]
  0 [label="0"];
  1 [label="1"];
  0 -> 1 [label="вверх"];
  0 -> 0 [label="вниз"];
  1 -> 1 [label="вверх"];
  1 -> 0 [label="вниз"];
}')

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  0 [label="закр."];
  1 [label="откр."];
  0 -> 1 [label="пропуск"];
  0 -> 0 [label="толчок"];
  1 -> 1 [label="пропуск"];
  1 -> 0 [label="толчок"];
}') 
```

```{r}
#| layout: "[[1,4],[1,4]]"

knitr::include_graphics("images/01_01_light_switch.jpg")
knitr::include_graphics("images/01_02_light_switch_automaton.png")
knitr::include_graphics("images/01_03_turnstile.jpg")
knitr::include_graphics("images/01_04_turnstile_automaton.png")
```

Мы не будем давать формального определения конечных автоматов, а перечислим свойства:

- алфавит, который автомат понимает;
- конечное количество состояний;
- переходы между состояниями;
- одно начальное состояние (часто обозначют нулем);
- набор конечных состояний (часто обозначают двойным кружочком).

Конечные автоматы можно использовать для верефикации поданного на вход слов:

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  0 [label="0"];
  1 [label="1"];
  2 [label="2"];
  3 [label="3"];
  4 [label="4: ✔️",shape=doublecircle];
  5 [label="5: ✘",shape=doublecircle];
  0 -> 1 [label="с"];
  0 -> 5 [label="не с"];
  1 -> 2 [label="л"];
  1 -> 5 [label="не л"];
  2 -> 3 [label="о"];
  2 -> 5 [label="не о"];
  3 -> 4 [label="н"];
  3 -> 5 [label="не н"];
}') 
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_05_elephant.png")
```

Если программа смогла пройти путь до конечного состояния (обозначен двойным кружочком), значит операция завершилась успехом, в остальных случаях --- неудачей. Обычно путь ведущей к неудаче не отображают.

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  0 [label="0"];
  1 [label="1"];
  2 [label="2"];
  4 [label="️4",shape=doublecircle];
  0 -> 1 [label="с"];
  1 -> 2 [label="л"];
  2 -> 3 [label="о"];
  3 -> 4 [label="н"];
}') 
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_06_elephant_short.png")
```

Можно сделать так, чтобы автомат верефицировал несколько слов:

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  0 [label="0"];
  1 [label="1"];
  2 [label="2"];
  5 [label="5"];
  6 [label="6"];
  7 [label="7"];
  8 [label="8"];
  9 [label="9"];
  10 [label="10"];
  11 [label="11"];
  12 [label="12"];
  4 [label="4",shape=doublecircle];
  
  0 -> 1 [label="с"];
  1 -> 2 [label="л"];
  2 -> 3 [label="о"];
  3 -> 4 [label="н"];
  
  0 -> 5 [label="у"];
  5 -> 6 [label="к"];
  6 -> 7 [label="л"];
  7 -> 8 [label="о"];
  8 -> 4 [label="н"];
  
  0 -> 9 [label="к"];
  9 -> 10 [label="у"];
  10 -> 11 [label="л"];
  11 -> 12 [label="о"];
  12 -> 4 [label="н"];
}')
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_07_multiple_words.png")
```

Полученный автомат можно оптимизировать, так, чтобы там было меньше узлов, а задачи он решал те же самые:

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  0 [label="0"];
  1 [label="1"];
  2 [label="2"];
  5 [label="5"];
  6 [label="6"];
  4 [label="4",shape=doublecircle];
  
  0 -> 1 [label="с"];
  1 -> 2 [label="л"];
  2 -> 3 [label="о"];
  3 -> 4 [label="н"];
  
  0 -> 5 [label="у"];
  5 -> 1 [label="к"];
  
  0 -> 6 [label="к"];
  6 -> 1 [label="у"];
}')
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_08_multiple_words_optimized.png")
```
