---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Автоматический морфологический анализ

Морфологический анализ, как его обычно видят лингвисты, обычно включает в себя несколько вещей:

- определение морфологической формы (например, латинское *mensam* --- [acc.sg]{.smallcaps});
- приведение к начальной форме или основе (*mensam* --- *mensa*, ж. р., первое склонение);
- перевод основы (*mensam* --- 'стол').

В зависимости от целей люди делают акцент на разные аспекты морфологического анализа. Для многих NLP задач полезным является приведение к начальной форме, лингвистический корпусной анализ практически невозможен без заранее определенных морфологических форм, и все три необходимы для представления языкового материала в научной работе. Также стоит помнить, что для разных задач могут быть важны разные категории, например, лингвисты, когда приводят примеры, редко перечисляют несловоизменительную информацию (например, род для существительных), которая может быть важна в каких-то задачах.

## Приведение к основе (stemming)

Достаточно широкое применение в ранюю эпоху NLP получили методы, которые позволяют привести словоформы к основе или квазиоснове. Эта процедура помогала уменьшить разнообразие форм в тексте, что облегчало поиск и извлечение информации. В работе [@singh17] приводится целая классификация стемеров:

```{r}
knitr::include_graphics("images/01_00_stemmers.png")
```

## Много данных

Обычно, если много данных, люди используют нейросети. Для морфологического анализа русского языка их использовали в следующих работах [@arefyev18; @sorokin18; @bolshakova19a; @bolshakova19b; @bolshakova20; @garipov23]. Используются разные архитектуры:

- cвёрточные нейронные сеть (convolutional neural network, CNN);
- деревья решения с градиентным бустингом (decision trees with gradient boosting);
- двунаправленная длинная цепь элементов краткосрочной памяти (Biderectional long short-term memory network, Bi-LSTM);
- и другие.

Другой важный проект, который можно упомянуть в этом разделе: [UDPipe](https://ufal.mff.cuni.cz/udpipe/2) --- проект, основанный на размечанных в формате [Universal Dependencies трибанках](https://universaldependencies.org/) большого количества языков  [@straka18]. Отметим, что их задача амбициознее: они строят модель, совмещающая морфологический парсер и синтаксический парсер дерева зависимостей. Внутри: длинная цепь элементов краткосрочной памяти (LSTM), которая работает на основе векторного представления слов.

Также стоит упомянуть проект [Morfessor](http://morpho.aalto.fi/projects/morpho/), в котором используют скрытые марковские цепи (HMM) [@gronroos14].

## Другие правиловые подходы

Стоит отметить, что существуют не основанные на трансдьюсерах правиловые подходы, например, 

- проект `uniparser-morph` Тимофея Архангельского [@arkhangelskiy12];
- нечто, что работает в SIL Fieldworks;
- множество узконаправленных парсеров, написанных для конкертных языков.

## От автоматов к морфологическим трансдьюсерам

### Конечные автоматы

Теория автоматов --- это дисциплина на стыке математики и компьютерных наук, которая появилась в XX веке. Первые конечных автоматов были предложены в работах [@mealy55; @moore56]. Данный раздел основан на первой главе из [@beesley03: 1--42].

Под автоматами мы понимаем абстрактные машины, которые принимают разные состояния, а изменение состояний вызывается некоторым действием:

```{r}
#| eval: false

library(DiagrammeR)
grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=18]
  0 [label="0"];
  1 [label="1"];
  0 -> 1 [label="вверх"];
  0 -> 0 [label="вниз"];
  1 -> 1 [label="вверх"];
  1 -> 0 [label="вниз"];
}')

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  0 [label="закр."];
  1 [label="откр."];
  0 -> 1 [label="пропуск"];
  0 -> 0 [label="толчок"];
  1 -> 1 [label="пропуск"];
  1 -> 0 [label="толчок"];
}') 
```

```{r}
#| layout: "[[1,4],[1,4]]"

knitr::include_graphics("images/01_01_light_switch.jpg")
knitr::include_graphics("images/01_02_light_switch_automaton.png")
knitr::include_graphics("images/01_03_turnstile.jpg")
knitr::include_graphics("images/01_04_turnstile_automaton.png")
```

Мы не будем давать формального определения конечных автоматов, а перечислим свойства:

- алфавит, который автомат понимает;
- конечное количество состояний;
- переходы между состояниями;
- одно начальное состояние (часто обозначют нулем);
- набор конечных состояний (часто обозначают двойным кружочком).

Конечные автоматы можно использовать для побуквенной верефикации поданных на вход слов:

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  4 [label="4: ✔️",shape=doublecircle];
  5 [label="5: ✘",shape=doublecircle];
  0 -> 1 [label="с"];
  0 -> 5 [label="не с"];
  1 -> 2 [label="л"];
  1 -> 5 [label="не л"];
  2 -> 3 [label="о"];
  2 -> 5 [label="не о"];
  3 -> 4 [label="н"];
  3 -> 5 [label="не н"];
}') 
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_05_elephant.png")
```

Если программа смогла пройти путь до конечного состояния (обозначен двойным кружочком), значит операция завершилась успехом, в остальных случаях --- неудачей. Обычно путь ведущей к неудаче не отображают.

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  4 [label="️4",shape=doublecircle];
  0 -> 1 [label="с"];
  1 -> 2 [label="л"];
  2 -> 3 [label="о"];
  3 -> 4 [label="н"];
}') 
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_06_elephant_short.png")
```

Можно сделать так, чтобы автомат верефицировал несколько слов:

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  4 [label="4",shape=doublecircle];
  
  0 -> 1 [label="с"];
  1 -> 2 [label="л"];
  2 -> 3 [label="о"];
  3 -> 4 [label="н"];
  
  0 -> 5 [label="у"];
  5 -> 6 [label="к"];
  6 -> 7 [label="л"];
  7 -> 8 [label="о"];
  8 -> 4 [label="н"];
  
  0 -> 9 [label="к"];
  9 -> 10 [label="у"];
  10 -> 11 [label="л"];
  11 -> 12 [label="о"];
  12 -> 4 [label="н"];
}')
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_07_multiple_words.png")
```

Полученный автомат можно оптимизировать, так, чтобы там было меньше узлов, а задачи он решал те же самые:

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  4 [label="4",shape=doublecircle];
  
  0 -> 1 [label="с"];
  1 -> 2 [label="л"];
  2 -> 3 [label="о"];
  3 -> 4 [label="н"];
  
  0 -> 5 [label="у"];
  5 -> 1 [label="к"];
  
  0 -> 6 [label="к"];
  6 -> 1 [label="у"];
}')
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_08_multiple_words_optimized.png")
```

Существуют математические работы, доказывающие, что для любого регулярного языка существует детерминированный конечный автомат с наименьшим возможным числом состояний. Такой автомат единственен с точностью до изоморфизма.

Важно отметить, что в данном разделе наши автоматы были представлены диаграммами состояний, однако автомат можно представить и в виде таблицы переходов, в которой каждая строка соотвествует одному состоянию, а столбцу допустимый входной символ (и выходной, если речь о трансдьюсерах). 

| исходное состояние | следующее состояние | входной символ |
|--------------------|---------------------|----------------|
| 0                  | 1                   | с              |
| 1                  | 2                   | л              |
| 2                  | 3                   | о              |
| 3                  | 4                   | н              |
| 0                  | 5                   | у              |
| 5                  | 1                   | к              |
| 0                  | 6                   | к              |
| 6                  | 1                   | у              |

### Трансдьюсеры

Все что мы рассмотрели до этого момента позволяло лишь принимать/отвергать слова, поданные на вход. Если мы немного усложним автомат, добавив в него еще выходной алфавит, то мы получим трансдьюсер (в [русской википедии](https://ru.wikipedia.org/wiki/Конечный_автомат_с_выходом) они названы конечными автоматами с выходом). Мы будем использовать обновленную нотацию: то, что пресдтавлено на вход мы пишется слева от двоеточия, а то, что получается на выходе --- справа.

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  4 [label="4",shape=doublecircle];
  
  0 -> 1 [label="с:с"];
  1 -> 2 [label="л:л"];
  2 -> 3 [label="о:о"];
  3 -> 4 [label="н:н"];
  
  0 -> 5 [label="у:у"];
  5 -> 1 [label="к:к"];
  
  0 -> 6 [label="к:к"];
  6 -> 1 [label="у:у"];
}')
```

```{r}
knitr::include_graphics("images/01_09_first_transducer.png")
```

Пока мы получили в добавку к проверке наших слов, которое обеспечивалось конечными автоматами, мы получаем нечто на выходе, пока в нашем примере на выходе получается то же самое, что на входе. Пустую строку принято обозначать греческой буквой эпсилон: `ε`. Таким образом мы можем представить трансдьюссер, который, наконец-то делает некоторый морфологический анализ.

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  9 [label="9",shape=doublecircle];
  
  0 -> 1 [label="с:с"];
  1 -> 2 [label="л:л"];
  2 -> 3 [label="о:о"];
  3 -> 4 [label="н:н"];
  
  0 -> 5 [label="у:у"];
  5 -> 1 [label="к:к"];
  
  0 -> 6 [label="к:к"];
  6 -> 1 [label="у:у"];
  
  4 -> 7 [label="ε:<n>"];
  7 -> 9 [label="ε:<nom><sg>"];
  7 -> 8 [label="о:<ins><sg>"];
  8 -> 9 [label="м:ε"];
}')
```


```{r}
knitr::include_graphics("images/01_10_morphology.png")
```

| вход      | выход                      |
|-----------|----------------------------|
| _слон_    | _слон_\<n\>\<nom\>\<sg\>   |
| _слоном_  | _слон_\<n\>\<ins\>\<sg\>   |
| _уклон_   | _уклон_\<n\>\<nom\>\<sg\>  |
| _уклоном_ | _уклон_\<n\>\<ins\>\<sg\>  |
| _кулон_   | _кулон_\<n\>\<nom\>\<sg\>  |
| _кулоном_ | _кулон_\<n\>\<ins\>\<sg\>  |

Лингвистические трансдьюсеры можно использовать для

- морфологического анализа
- транслитерации/транскрипции
- предективного ввода
- в системах проверки правописания
- в системах автоматического перевода близкородственных языков
- и др.

С трансдьюсерами можно делать много разных операций: 
- объединение (конечные и начальные состояния совпадают, все промежуточные сохраняются);
- конкатенация (конечное состояние одного трансдьюсера становится начальным состоянием другого);
- пересечение (в особых случаях;
- вычитание (в особых случаях);
- композиция (обсудим ниже).

Композиция трансдьюсеров аналогична функциям `join` для таблиц. После композиции трансдьюсера <x, y>  и <y, z>  получается новый трансдьюсер <x, z>.

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  6 [label="6",shape=doublecircle];
  12 [label="12",shape=doublecircle];
  19 [label="19",shape=doublecircle];
  
  0 -> 1 [label="в:c"];
  1 -> 2 [label="о:r"];
  2 -> 3 [label="р:o"];
  3 -> 4 [label="о:w"];
  4 -> 5 [label="н:ε"];
  5 -> 6 [label="а:ε"];
  7 -> 8 [label="w:с"];
  8 -> 9 [label="r:r"];
  9 -> 10 [label="o:o"];
  10 -> 11 [label="n:w"];
  11 -> 12 [label="a:ε"];
  13 -> 14 [label="в:w"];
  14 -> 15 [label="о:r"];
  15 -> 16 [label="р:o"];
  16 -> 17 [label="о:n"];
  17 -> 18 [label="н:a"];
  18 -> 19 [label="а:ε"];
}')
```

```{r}
knitr::include_graphics("images/01_11_transducer_composition.png")
```

Именно при помощи композиции трансдьюсеров можно объединять трансдьюсеры с разными "целями": например, трансдьюсер, который приводит к начальной форме и пишет морфологические теги, с трансдьюсером, который переводит основы.

Закончим перечислением преимуществ трансдьюссеров. Оптимизированный трансдьюсер является оптимальным с точки зрения объема требуемой памяти для хранения и скорости поиска. Композиция трансдьюсеров открывает большой и богатый мир, которые позволяет создавать и комбинировать между собой очень разные инструменты.

## Проблемы моделирования морфологии языка

- Проблема описаний:
    - неполнота: то, что исследователи посчитали достаточным для грамматического описания, может быть недостаточно для моделирования; для некоторого языка может быть доступно грамматическое описание, но отсутствовать словарь и наоборот; словарь может не содержать информации про словоизменительный класс каких-то единиц, которые различаются в грамматическом описании.
    - противоречивые источники: грамматические описания могут противоречить друг другу; грамматические описания могут противоречить словарям
- Проблема вариативности:
    - идиолектная
    - диалектная
    - связанная с какими-нибудь социолингвистическими параметрами (в первую очередь такие как пол и возраст, но можно придумать и другие)
- Проблема неоднозначности (особенно перекошенной частотно):
    - лексической
    - морфологическая
    - синтаксическая
    - ...
- Проблема идиом и суплетивизма: в какой форме стоит глагол в ругательстве *\*\* твою мать*?
- Проблема циклов, возникающих при словообразовании:
    - слуга (N) > служить (V) > услужить (V) > услужение (N), услуга (N)[^etymology]
    
[^etymology]: Я лишь предполагаю такую историческую деревацию, возможно, этимологии этих слов таят в себе значительно более сложную историю.